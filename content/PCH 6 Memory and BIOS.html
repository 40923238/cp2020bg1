<!DOCTYPE html><html>
        <head>
        <title>CMSiMDE</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <link href="https://fonts.googleapis.com/css?family=Quicksand:300,400,500,700,900" rel="stylesheet">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/fonts/icomoon/style.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/bootstrap.min.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/magnific-popup.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/jquery-ui.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/owl.carousel.min.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/owl.theme.default.min.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/bootstrap-datepicker.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/fonts/flaticon/font/flaticon.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/aos.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/style.css">
        <link rel="shortcut icon" href="./../cmsimde/static/favicons.png">
        
        <style type='text/css'>
            .site-section {
            background-color: #FFFF;
            padding: 40px 40px;
            }
            body > div > div.dropdown.open {
                display: block;
            }
        </style>
    
        <!-- <script src="./../cmsimde/static/jquery.js"></script> -->
        <!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script> -->
        <script src="../cmsimde/static/chimper/js/jquery-3.3.1.min.js"></script>
        <link rel="stylesheet" href="./../cmsimde/static/tipuesearch/css/normalize.min.css">
        <script src="./../cmsimde/static/tipuesearch/tipuesearch_set.js"></script>
        <script src="tipuesearch_content.js"></script>
        <link rel="stylesheet" href="./../cmsimde/static/tipuesearch/css/tipuesearch.css">
        <script src="./../cmsimde/static/tipuesearch/tipuesearch.js"></script>
        <script>
            /* original tipuesearch
            $(document).ready(function() {
                 $('#tipue_search_input').tipuesearch();
            });
            */
            // customed doSearch
            function doSearch() {
                $('#tipue_search_input').tipuesearch({
                    newWindow: true, 
                    minimumLength: 2,
                    wholeWords: false, // for search 中文
                });
            }
            $(document).ready(doSearch);
        </script>
        
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shCore.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushBash.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushDiff.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushJScript.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushJava.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushPython.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushSql.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushHaxe.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushXml.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushPhp.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushLua.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushCpp.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushCss.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushCSharp.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushDart.js"></script>
<link type="text/css" rel="stylesheet" href="./../cmsimde/static/syntaxhighlighter/css/shCoreDefault.css"/>
<script type="text/javascript">SyntaxHighlighter.all();</script>
<!-- 暫時不用
<script src="./../cmsimde/static/fengari-web.js"></script>
<script type="text/javascript" src="./../cmsimde/static/Cango-13v08-min.js"></script>
<script type="text/javascript" src="./../cmsimde/static/CangoAxes-4v01-min.js"></script>
<script type="text/javascript" src="./../cmsimde/static/gearUtils-05.js"></script>
-->
<!-- for Brython 暫時不用
<script src="https://scrum-3.github.io/web/brython/brython.js"></script>
<script src="https://scrum-3.github.io/web/brython/brython_stdlib.js"></script>
-->
<style>
img.add_border {
    border: 3px solid blue;
}
</style>

</head>
<body>
<div class='container'><nav>
        
    <div class="site-wrap">

    <div class="site-mobile-menu">
      <div class="site-mobile-menu-header">
        <div class="site-mobile-menu-close mt-3">
          <span class="icon-close2 js-menu-toggle"></span>
        </div>
      </div>
      <div class="site-mobile-menu-body"></div>
    </div>
    
            <header class="site-navbar py-4 bg-white" role="banner">
              <div class="container-fluid">
                <div class="row align-items-center">
                <h1>cp2020bg1</h1>
                <div class="pl-4">
                    <form>
                    <input type="text" placeholder="Search" name="q" id="tipue_search_input" pattern=".{2,}" title="At least 2 characters" required>
                    </form>
                </div>
                  <!-- <div class="col-11 col-xl-2">
                    <h1 class="mb-0 site-logo"><a href="index.html" class="text-black h2 mb-0">cp2020bg1</a></h1> 
                  </div>
                  -->
                  <div class="col-12 col-md-10 d-none d-xl-block">
                    <nav class="site-navigation position-relative text-right" role="navigation">
    <ul class='site-menu js-clone-nav mr-auto d-none d-lg-block'>
                        <li class="active has-children"><a href="index.html">Home</a>
                        <ul class="dropdown">
                            <li><a href="sitemap.html">Site Map</a></li>
                            <li><a href="./../reveal/index.html">reveal</a></li>
                            <li><a href="./../blog/index.html">blog</a></li>
                        </ul>
                      </li>
                     <li><a href='About.html'>About</a><li><a href='Teammate.html'>Teammate</a><li class='has-children'><a href='HW1.html'>HW1</a><ul class='dropdown'><li class='has-children'><a href='40923203陳宥歆-1.html'>40923203陳宥歆-1</a><ul class='dropdown'><li><a href='PCH4 Cases Form Factors and Power Supplies 外殼外形尺寸和電源.html'>PCH4 Cases Form Factors and Power Supplies 外殼外形尺寸和電源</a><li><a href='PCH7 Expansion Cards Audio Video and Storage 擴充卡 音頻 視頻和存儲 1.html'>PCH7 Expansion Cards Audio Video and Storage 擴充卡 音頻 視頻和存儲 1</a><li><a href='PCH7 Expansion Cards Audio Video and Storage 擴充卡 音頻 視頻和存儲 2.html'>PCH7 Expansion Cards Audio Video and Storage 擴充卡 音頻 視頻和存儲 2</a></li></ul><li><a href='40923208葉媛婷-1.html'>40923208葉媛婷-1</a><li class='has-children'><a href='40923209盧詩婷-1.html'>40923209盧詩婷-1</a><ul class='dropdown'><li><a href='PCH5 Motherboards,Expansion Buses,and Processors 主機板，擴充總線，處理器.html'>PCH5 Motherboards,Expansion Buses,and Processors 主機板，擴充總線，處理器</a><li><a href='PCH5 Expansion Slots 擴展槽.html'>PCH5 Expansion Slots 擴展槽</a><li><a href='PCH5 Jumpers 跳線.html'>PCH5 Jumpers 跳線</a><li><a href='PCH5 Processor History 處理器歷史記錄.html'>PCH5 Processor History 處理器歷史記錄</a><li><a href='PCH5 Virtualization 虛擬化.html'>PCH5 Virtualization 虛擬化</a><li><a href='PCH5 CPU Cooling  CPU散熱.html'>PCH5 CPU Cooling  CPU散熱</a></li></ul><li class='has-children'><a href='40923230黃暐哲-1.html'>40923230黃暐哲-1</a><ul class='dropdown'><li><a href='UNIT1 Succeeding in PC Hardware.html'>UNIT1 Succeeding in PC Hardware</a></li></ul><li><a href='40923223游尚霖-1.html'>40923223游尚霖-1</a><li><a href='介紹.html'>介紹</a><li class='has-children'><a href='Power Supplies.html'>Power Supplies</a><ul class='dropdown'><li><a href='Power Variation.html'>Power Variation</a><li><a href='Protecting People and Property.html'>Protecting People and Property</a><li><a href='Operational Procedures: Electrostatic Discharge.html'>Operational Procedures: Electrostatic Discharge</a><li><a href='Operational Procedure Environmental Controls.html'>Operational Procedure Environmental Controls</a></li></ul><li><a href='40923225黃亦銘-1.html'>40923225黃亦銘-1</a><li><a href='40923230黃暐哲-2.html'>40923230黃暐哲-2</a><li class='has-children'><a href='40923238鄒杰-1.html'>40923238鄒杰-1</a><ul class='dropdown'><li><a href='PCH 6 Memory and BIOS.html'>PCH 6 Memory and BIOS</a><li><a href='PCH 18: Laptop and Notebook Component Replacement.html'>PCH 18: Laptop and Notebook Component Replacement</a></li></ul><li class='has-children'><a href='40923239蔡育嘉-1.html'>40923239蔡育嘉-1</a><ul class='dropdown'><li><a href='Pch 1.html'>Pch 1</a><li><a href='Pch 17.html'>Pch 17</a></li></ul><li><a href='40923244鄭宇佑-1.html'>40923244鄭宇佑-1</a><li><a href='40923249戴揚哲-1.html'>40923249戴揚哲-1</a></li></ul><li><a href='HW2.html'>HW2</a><li class='has-children'><a href='HW3.html'>HW3</a><ul class='dropdown'><li><a href='40923203陳宥歆-2.html'>40923203陳宥歆-2</a><li><a href='40923208葉媛婷-2.html'>40923208葉媛婷-2</a><li><a href='40923209盧詩婷-2.html'>40923209盧詩婷-2</a><li><a href='40923210羅諭琳.html'>40923210羅諭琳</a><li><a href='40923223游尚霖-2.html'>40923223游尚霖-2</a><li><a href='40923225黃亦銘-2.html'>40923225黃亦銘-2</a><li><a href='40923230黃暐哲-3.html'>40923230黃暐哲-3</a><li><a href='40923238鄒杰-2.html'>40923238鄒杰-2</a><li><a href='40923239蔡育嘉-2.html'>40923239蔡育嘉-2</a><li><a href='40923244鄭宇佑-2.html'>40923244鄭宇佑-2</a><li><a href='40923249戴揚哲-2.html'>40923249戴揚哲-2</a></li>
                      </ul>
                </nav>
              </div>
              <div class="d-inline-block d-xl-none ml-md-0 mr-auto py-3" style="position: relative; top: 3px;"><a href="#" class="site-menu-toggle js-menu-toggle text-black"><span class="icon-menu h3"></span></a></div>
              </div>

            </div>
          </div>
          
        </header>
    <div id="tipue_search_content">40923238鄒杰-1 << <a href='40923238鄒杰-1.html'>Previous</a> <a href='PCH 18: Laptop and Notebook Component Replacement.html'>Next</a> >> PCH 18: Laptop and Notebook Component Replacement<br /><h1>PCH 6 Memory and BIOS</h1>
<p><strong>PCH 6 Memory and BIOS</strong></p>
<p><strong>RAM Basics</strong></p>
<p>In order for a computer to function, it needs a temporary storage space to store data that is input into the computer from the user or the hard drive, and to store data that is about to be written to more permanent storage. This temporary storage is called RAM, or random access memory. RAM is the workspace for the CPU to process data. When the computer boots up the OS (operating system) loads the start files into RAM. RAM is dynamic and constantly changing. It operates much faster than a hard drive, and can be changed at any time by the computer. RAM is volatile memory which means it loses all its information when power is removed, so it can only be used as temporary storage. This memory is used for operating systems startup files (bootstrap loader), programs, data, and disk caching. Adding RAM to a computer is one of the easiest and most effective upgrades a person can perform, since it drastically improves the transfers between the CPU and the other input devices (like hard drives), and this increases the overall speed of the computer.</p>
<p><img alt="" height="312" src="./../images/6-1.png" width="312"/></p>
<p><strong>PCH6:Memory and BIOS</strong></p>
<p><img alt="" height="291" src="./../images/6-1.png" width="291"/></p>
<p><strong></strong></p>
<p>為了使電腦正常運行，它需要一個臨時存儲空間來存儲從用戶或硬碟輸入到電腦中的數據，並將要寫入的數據存儲到更永久的存儲裝置中。該臨時存儲區稱為RAM或隨機存取存儲器。RAM是CPU處理數據的工作區。電腦啟動系統時（操作系統）將啟動資料加載到RAM中。RAM是動態的並且不斷變化。它的運行速度比硬碟驅動器快得多，並且可由電腦隨時更改。RAM是揮發性記憶體，這意味著在斷電時它會失去所有資料，因此只能用作臨時存儲。該記憶體用於操作系統啟動文件（引導加載程序）、程序、資料和磁碟緩存。在電腦裡增加RAM是一個最簡單，最有效的升級之一，因為它可以極大地改善CPU與其他輸入設備（如硬碟）之間的傳輸，從而提高了電腦運行的整體速度。</p>
<p>One of the uses of memory is to serve as a disk cache. Like the caches we mentioned in the processor, the RAM acts as a faster, temporary storage area for recently used and commonly used data from the hard drive. Because it is quicker to access RAM than to seek out the data in the hard drive’s sectors, RAM increases the performance of the machine. Disk caching can be used only when there is available extra space in the memory. But what happens if you do not have enough physical memory available? When there is not enough physical memory, the computer creates virtual memory. Virtual memory is sometimes referred to as "page files" or “swap files.” Virtual memory is a slow substitute for RAM since it is a temporary file created on the hard drive and emulates the physical RAM. Essentially, disk caching allows RAM to act like an extremely fast hard drive, while virtual memory consists of files on the hard drive acting as extremely slow memory. RAM is faster than either magnetic storage (like hard drives and floppy disks) or optical storage (DVD, CD, Blu-ray). This is because RAM is a solid-state device without exceedingly long access times. RAM operates in the billionths of a second (nanoseconds), while hard drives and other magnetic media are very slow, operating in the thousandths of a second (milliseconds). Insufficient RAM causes a computer to operate more slowly. So, upgrading RAM is one of the most common upgrades performed by an A+ technician.</p>
<p><img alt="" height="240" src="./../images/6-2.png" width="320"/></p>
<p>記憶體的用途之一是充當磁碟緩存。就像我們在處理器中提到的緩存一樣，RAM為硬碟中最近使用和常用的資料提供了更快的臨時存儲區。由於讀取RAM比查找磁碟區中的數據更快，因此RAM可提高電腦的性能。僅有在記憶體中有可用空間時才可以使用磁碟緩存。但是，如果您沒有足夠的物理內存可用怎麼辦？當物理內存不足時，電腦將創建虛擬記憶體。虛擬記憶體有時也稱為“分頁檔”或“交換空間”。虛擬記憶體是RAM的慢速替代品，因為它是在硬碟上創建的臨時空間，並模擬物理記憶體。本質上，磁碟緩存使RAM可以充當極快的硬碟，而虛擬記憶體由硬碟上的組成，它們的運行速度非常慢。 RAM的速度比其他磁存儲（如硬碟和軟碟）或光存儲（DVD，CD，藍光）要快。這是因為RAM是固態設備，讀取時間很短。 RAM的運行速度為十億分之一秒，而硬碟和其他磁性介質的運行速度非常慢，其運行速度為千分之一秒（毫秒）。 RAM不足會導致電腦運行變慢。因此，升級RAM是A +技術人員執行的最常見的升級之一。</p>
<p><strong>Classifying Memory</strong></p>
<p>There are multiple classifications for RAM: memory module type, chip type, speed, and parity. Memory modules vary by type, which is defined by the motherboard and the motherboard’s form factor. Memory modules are defined by the number of pins they have on the modules, like 240-pin DIMM (dual in-line memory module), 184-pin DIMM, etc.</p>
<p>RAM is also classified based upon memory chip type. In the past, systems used different types of chips based on their manufacturer, but current systems use mostly the same type, usually DDR (dual data rate), DDR2, or DDR3. Although the DDR is the most common type, some unique systems may use RDRAM (Rambus dynamic random access memory).</p>
<p>Another RAM classification is based on speed. Older memory was classified in nanoseconds (for example, 60 nanoseconds). Over time, all memory became nearly the same speed, as measured in nanoseconds, so they changed this to bus speed (for example, PC-133 memory operates at a bus speed of 133 MHz). Most contemporary memory is now measured in throughput (PC2-6400, which operates at 800 MHz but has 6.4 GBps of bandwidth).</p>
<p>Finally, memory can be purchased with and classified by parity, non-parity, or ECC. Parity memory checks for errors as data is read/written to the chip. While parity memory can detect an error, it cannot correct it. Non-parity memory, one of the most common types found in desktop computers, has no error checking ability. Error correcting code (ECC) is an advanced version of parity that can find an error and correct that error as it is read/written from the chip. Due to these additional functions, ECC tends to be slower than equivalent non-parity RAM.</p>
<p><img alt="" height="123" src="./../images/6-3.png" width="185"/></p>
<p><img alt="" height="136" src="./../images/6-3.png" width="205"/></p>
<p>記憶分類</p>
<p><span>RAM</span>有多種分類<span>:</span>記憶體模組類型、芯片類型、速度和奇偶校驗。記憶體模組因類型而異，具體取決於主機板的外形尺寸。記憶體模塊由其上的針腳數量定義，例如<span>240</span>針<span>DIMM</span>（雙列直插式記憶體模組），<span>184</span>針<span>DIMM</span>等。</p>
<p><span>RAM</span>也根據存儲芯片類型進行分類。過去，系統根據製造商使用不同類型的芯片，但是當前的系統大多使用相同類型的芯片，通常是<span>DDR</span>（雙數據速率），<span>DDR2</span>或<span>DDR3</span>。儘管<span>DDR</span>是最常見的類型，但某些獨特的系統可能會使用<span>RDRAM</span>（<span>Rambus</span>動態隨機存取存儲器）。</p>
<p>另一個<span>RAM</span>分類基於速度。較舊的內存以奈秒（例如<span>60</span>奈秒）分類。隨著時間的流逝，所有內存的速度幾乎相同，以奈秒為單位，因此他們將其更改為總線速度（例如，<span>PC-133</span>內存以<span>133 MHz</span>的總線速度運行）。現在，大多數當代內存都是按吞吐量衡量的（<span>PC2-6400</span>，工作於<span>800 MHz</span>，但具有<span>6.4 GBps</span>的帶寬）。</p>
<p>最後，可以使用奇偶校驗，非奇偶校驗或<span>ECC</span>購買存儲器並按其分類。奇偶校驗存儲器在將數據讀<span>/</span>寫到芯片時檢查錯誤。儘管奇偶校驗內存可以檢測到錯誤，但無法糾正錯誤。非奇偶校驗內存是台式計算機中最常見的類型之一，沒有檢查錯誤的功能。除錯碼（<span>ECC</span>）是奇偶校驗的高級版本，可以發現錯誤並在從芯片讀取<span>/</span>寫入該錯誤時對其進行糾正。由於這些附加功能，<span>ECC</span>往往比等效的非奇偶校驗<span>RAM</span>慢。</p>
<p><strong>Determining Type of Memory Based on Motherboard</strong></p>
<p>The type of memory that you need to use is determined by the motherboard. The best practice is to check the motherboard’s manual for the proper type, size, and speed of memory before purchasing new modules. Some motherboards will allow you to mix the sizes of the modules, while others require all modules to be the same size. For example, if there are two memory slots on a motherboard, it may allow you to put a 1 GB module in one slot, and a 2 GB module in another. Other motherboards require all slots to have the same size chips in them, such as 1 GB modules in both slots. Another factor to consider is the “bank” size of the motherboard. Some motherboards support a bank of one, meaning you can use a single module in the motherboard. Other motherboards require two modules to complete a bank (the slots must be filled in pairs).</p>
<p>Another feature that your motherboard may support is called dual-channel or triple-channel. In these channel modes, the motherboard requires that the user install identical size and speed modules in two (dual) or three (triple) slots. This allows for the interleaving of memory access for faster performance times of the memory, speeding up the computer’s operations. Think about interleaving as if you had two horses pulling a cart instead of one. While each horse may be able to pull 100 pounds on its own, together they can pull 250 pounds. Interleaving in the context of memory is the same idea—speed of access increases when memory is interleaved. The sum total of both memory chips can be accessed faster together than either could individually.</p>
<p>Finally, the total number of modules that can be installed is also determined by the motherboard’s form factor. If you have a smaller form factor motherboard, such as mini-ATX, it may have fewer slots for modules (maybe two slots versus four or six on a full ATX board).</p>
<p><span> </span></p>
<p>基於主機板確定內存類型</p>
<p>您需要使用的內存類型由主機板決定。最佳做法是在購買新模組之前，先檢查主機板手冊中的內存類型，大小和速度是否正確。某些主機板可讓您混合使用模組的大小，而另一些則要求所有模組的大小均相同。例如，如果主機板上有兩個記憶體插槽，則可能允許您在一個插槽中放置一個1 GB的模組，在另一個插槽中放置一個2 GB的模組。其他主機板要求所有插槽中都具有相同大小的芯片，例如兩個插槽中都有1 GB的模組。要考慮的另一個因素是主機板的“庫”大小。一些主機板支持一組，這意味著您可以在主機板中使用單個模組。其他主機板需要兩個模組來完成存儲（插槽必須成對填充）。</p>
<p>主機板可能支持的另一個功能稱為雙通道或三通道。在這些通道模式下，主機板要求用戶在兩個（雙）或三個（三重）插槽中安裝相同尺寸和速度的模組。這樣可以交錯訪問內存，以加快內存的性能，從而加快計算機的運行速度。思考一下，就好像您有兩匹馬拉著一輛馬車。雖然每匹馬可以自己可以拉100磅，但它們合起來可以拉250磅。在內存在運行中進行交錯是相同的想法—交錯記憶體時讀取速度會提高。一起讀取兩個記憶體芯片的總和比單獨讀取一個芯片更快。</p>
<p>最後，可安裝的模組總數也由主機板的外形尺寸決定。如果您使用的是較小型的主機板，例如mini-ATX，則其模組插槽可能會更少（也許是兩個插槽，而完整的ATX板上則是四個或六個）。</p>
<p></p>
<p>Different types of RAM have been in common use during different time periods. It is important to understand them all, because many companies use a mix of legacy systems and more current ones. DRAM, or dynamic RAM, is one of the oldest types. It requires frequent refreshing of contents. DRAM stores each bit of data or program code in a storage cell consisting of a capacitor and a transistor, and is typically organized in a rectangular configuration of storage cells. A DRAM storage cell is dynamic in that it needs to be refreshed or given a new electronic charge every few milliseconds to compensate for charge leaks from the capacitor.</p>
<p>SRAM, or static RAM, solved the issue of the need for constant refreshing, but it is quite expensive to manufacture. Therefore, SRAM is only used for very high-speed needs, such as level 1, level 2, and level 3 CPU caches, hard drive buffers, and LCD screen buffers.</p>
<p>SDRAM, or synchronous DRAM, was the first memory that operated at the same speed as the motherboard’s bus. The initial chips were 168-pin dual in-line memory modules, which have their speed rated in MHz. Common naming conventions include PC-66 (which is equivalent to 66 Mhz), or PC-133, or PC-266.</p>
<p>While SDRAM performs at the same speed as the motherboard’s bus, the CPU operates many times faster than the motherboard’s bus. DDR SDRAM stands for double data rate synchronous dynamic random access memory. This type of memory can transfer data two times per clock cycle, thereby doubling the speed over traditional SDRAM. These chips come in 184-pin varieties, rated in MBps (throughput). A good example of this is something like PC-1600, which is 1600 MBps throughput.</p>
<p>DDR2 SDRAM is double double data rate SDRAM, which has a higher <strong><em>latency</em></strong> but faster access to the external bus. These chips have 240 pins to connect their modules to the slot, and are also rated in MBps, such as PC2-4200, which is 4200 MBps (or 4.2 GBps).</p>
<p>DDR3 SDRAM is known as double data rate 3 SDRAM, and is the latest generation of SDRAM in use today. It runs at a lower voltage and is faster than DDR2, but again the latency is increased over the previous DDR2 modules. These modules also have 240 pins, but they are “keyed” differently than DDR2. The “keyed” portion is where the gap in the pins is located, so only a DDR2 will fit in a DDR2 slot, and a DDR3 will fit only in a DDR3 slot. The common notation for these is PC3-10600, where the 10600 is the speed in MBps.</p>
<p>Rambus direct ram (RDRAM) is also known as RIMM (Rambus in-line memory module). These modules come in a 184-pin variant (16-bit version) and a 232-pin variant (32-bit version). Each empty slot in the motherboard has to have a continuity module (CRIMM) placed inside it, or the motherboard won’t recognize the memory properly. This is not used in recent systems, but was used heavily in Pentium 4 systems. The RDRAM is measured in MBps, such as RIMM 4200 (or 4200 MBps).</p>
<p><img alt="" height="311" src="./../images/6-4.jpg" width="415"/></p>
<p><img alt="" height="295" src="./../images/6-4.jpg" width="394"/></p>
<p>在不同時間裡，使用的RAM是不同類型。了解所有這些信息非常重要，因為許多公司是舊系統和最新系統混合使用。 DRAM或動態RAM是最古老的類型之一。它需要經常刷新內容。 DRAM將數據或程序代碼的每一位存儲在由電容器和晶體管組成的存儲單元中，並且通常以矩形配置的存儲單元來組織。 DRAM處存單元是動態的，因為它需要每幾毫秒刷新一次或給其提供新的電荷，以補償電容器的電荷洩漏。</p>
<p>SRAM或靜態RAM解決了持續刷新的問題，但製造成本很高。因此，SRAM僅用於非常高速的需求，例如1級，2級和3級CPU高速緩存，硬碟緩衝區和LCD螢幕緩衝區。</p>
<p>SDRAM或同步DRAM是第一個以與主板總線相同的速度運行的內存。最初的芯片是168針雙列直插式內存模組，其速度額定為MHz。常見的命名約定包括PC-66（相當於66 Mhz），PC-133或PC-266。</p>
<p>儘管SDRAM的性能與主板總線相同，但CPU的運行速度比主板總線快許多倍。 DDR SDRAM代表雙倍數據速率同步動態隨機存取存儲器。這種類型的存儲器可以在每個時段週期兩次傳輸數據，從而使速度比傳統SDRAM快一倍。這些芯片有184引腳的型號，額定為MBps（吞吐量）。一個很好的例子就是PC-1600，吞吐量為1600 MBps。</p>
<p>DDR2 SDRAM是雙倍數據速率SDRAM，具有更高的延遲，但對外部總線的讀取速度更快。這些芯片具有240個針腳以將其模組連接到插槽，並且還以MBps額定，例如PC2-4200，即4200 MBps（或4.2 GBps）。</p>
<p>DDR3 SDRAM被稱為雙倍資料傳輸率3 SDRAM，是當今使用的最新一代SDRAM。它在較低的電壓下運行，並且比DDR2更快，但是與之前的DDR2模組相比，延遲又增加了。這些模組也具有240個針腳，但是它們的“鍵控”與DDR2不同。 “鍵控”部分是針腳之間的間隙所在的位置，因此只有DDR2可以插入DDR2插槽，而DDR3只能插入DDR3插槽。這些的常用符號是PC3-10600，其中10600是MBps的速度。</p>
<p>Rambus RAM（RDRAM）也被稱為RIMM（Rambus嵌入式存儲模組）。這些模組具有184針變種（16位版本）和232針變種（32位版本）。主板上的每個空插槽都必須在其中放置一個連續性模組（CRIMM），否則主板將無法正確識別內存。在最近的系統中未使用此功能，但在Pentium 4系統中大量使用了此功能。 RDRAM以MBps為單位進行度量，例如RIMM 4200（或4200 MBps）。</p>
<p lang=""><span></span></p>
<p style="line-height: 18.0pt; background: white; vertical-align: baseline; margin: 6.0pt 0cm 9.6pt 0cm;"><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Georgia',serif; color: #241d1d;">There are other variants of memory that have been used over the years, but they are not common today. The single inline memory module, or SIMM, has either 30 or 72 connectors on both sides of the chip. The single inline pin package, or SIPP, has only 30 pins, and they are physical pins instead of connectors.<o:p></o:p></span></p>
<p style="line-height: 18.0pt; background: white; vertical-align: baseline; margin: 6.0pt 0cm 9.6pt 0cm;"><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Georgia',serif; color: #241d1d;">Dual inline memory module, or DIMM, is what is used for DDR, DDR2, and DDR3 chips, with each side of the module having different pinouts in the connectors. The SODIMM, small outline DIMM, is a compact version of memory used in laptops, notebooks, and printers. It can come in DDR SODIMM, DDR2 SODIMM, or DDR3 SODIMM. SODIMM is very common and still heavily used today.<o:p></o:p></span></p>
<p style="line-height: 18.0pt; background: white; vertical-align: baseline; margin: 6.0pt 0cm 9.6pt 0cm;"><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Georgia',serif; color: #241d1d;">Finally, there is a laptop version of Rambus memory called small outline Rambus module, but it is rarely used in contemporary systems.<o:p></o:p></span></p>
<p style="line-height: 18.0pt; background: white; vertical-align: baseline; margin: 6.0pt 0cm 9.6pt 0cm;"><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Georgia',serif; color: #241d1d;"><img alt="" height="168" src="./../images/6-5.png" width="299"/></span></p>
<p style="line-height: 18.0pt; background: white; vertical-align: baseline; margin: 6.0pt 0cm 9.6pt 0cm;"><img alt="" height="168" src="./../images/6-5.png" width="299"/></p>
<p>多年以來，內存還使用了其他變體，但今天並不常見。 單列直插式內存模組或SIMM在芯片的兩側都有30或72個連接器。 單列直插式引腳封裝或SIPP只有30個針腳，它們是物理針腳而不是連接器。</p>
<p>DDR，DDR2和DDR3芯片使用雙列直插式內存模組或DIMM，模塊的每一側在連接器中具有不同的針腳排列。 SODIMM是小型DIMM，是便攜式電腦，筆記本電腦和打印機中使用的緊湊型記憶體。 它可以採用DDR SODIMM，DDR2 SODIMM或DDR3 SODIMM。 SODIMM非常普遍，今天仍然大量使用。</p>
<p>最後，有一個筆記本電腦版本的Rambus存儲器，稱為小型Rambus模組，但在現代系統中很少使用</p>
<p><strong>Memory Module Width</strong></p>
<p>Memory module width is measured by the number of bits that can be transferred. Memory began in 8-bit varieties, but has increased to 16 bits, 32 bits, and now 64 bits in current systems. Memory must be added in banks to ensure the width equals the width of the memory bus. For example, if you need 64 bits and a single module offers 64 bits, then it will have one module in the bank. Dual-channel memory requires double the amount, therefore two 64-bit (128 bit) DIMMs are needed in the banks, while three are required for triple-channel, as was mentioned earlier.</p>
<p><img alt="" height="390" src="./../images/6-6.png" width="444"/></p>
<p>記憶體模組寬度</p>
<p>記憶體模組的寬度由可傳輸的位數決定。 內存最初以8位形式出現，但在當前系統中已增加到16位，32位和現在的64位。 必須以存儲體的形式添加內存，以確保其寬度等於記憶體總線的寬度。 例如，如果您需要64位，而單個模組提供64位，則庫中將只有一個模組。 如前所述，雙通道內存需要兩倍的存儲量，因此存儲庫中需要兩個64位（128位）DIMM，而三通道則需要三個。</p>
<p><em><strong>Parity and ECC</strong></em></p>
<p>Parity is used to perform basic error checking and to ensure the memory contents are reliable. This memory is slower than non-parity, but adds the reliability needed for servers and certain desktop workstations.</p>
<p>Parity checking is a rather simple method of detecting memory errors, without any correction capabilities. Parity is signified in a single bit of data that is added to the transmitted data string. If the module normally would have seven bits of data, an eighth is added as the parity bit. If the module normally would have eight chips for data, a ninth chip is added for parity.</p>
<p>Every byte has a parity bit associated with it. In the case that seven bits make up the original data, there are eight total bits transmitted (seven original data bits plus one parity bit). In the case that eight bits make up the original data, a total of nine bits are transmitted (eight data bits plus one parity bit). The parity bit is set at write time, and then calculated and compared at read time to determine if any of the bits have changed since the data was stored. This type of checking is limited to detection of single bit errors. If two bits have been altered, the parity check will “pass,” and the error is allowed to possibly corrupt the data.</p>
<p>Parity checking can be implemented either as “0” parity or “1” parity. When the byte is stored, the number of zeros (or ones, if “1” parity is selected) is added up. The result is stored in the parity bit – “1” if odd, “0” if even. When that byte is read from memory, the bits are again counted and the result is compared against what was stored in the parity bit. A match means that the data was not changed from when it was stored (or that two bits were altered in such a way that the result is the same).</p>
<p>The process to determine the parity bit is the same, regardless of the number of original data bits transmitted. Typically, there are either seven or eight bits of original data.</p>
<p>The parity bit is determined by counting the number of “1” bits in a data string.</p>
<table>
<thead>
<tr>
<td></td>
<td colspan="2">
<p><strong>Set parity bit to:</strong></p>
</td>
</tr>
<tr>
<td></td>
<td>
<p><strong>Even parity</strong></p>
</td>
<td>
<p><strong>Odd parity</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<p><strong>Even number of “1” bits</strong></p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>1</p>
</td>
</tr>
<tr>
<td>
<p><strong>Odd number of “1” bits</strong></p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>0</p>
</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<td></td>
<td colspan="2">
<p><strong>Set parity bit to:</strong></p>
</td>
</tr>
<tr>
<td></td>
<td>
<p><strong>Even parity</strong></p>
</td>
<td>
<p><strong>Odd parity</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<p><strong>Even number of “1” bits</strong></p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>1</p>
</td>
</tr>
<tr>
<td>
<p><strong>Odd number of “1” bits</strong></p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>0</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Set parity bit to:</strong></p>
<p><strong>Even parity</strong></p>
<p><strong>Odd parity</strong></p>
<p><strong>Even number of “1” bits</strong></p>
<p>0</p>
<p>1</p>
<p><strong>Odd number of “1” bits</strong></p>
<p>1</p>
<p>0</p>
<p><strong>Set parity bit to:</strong></p>
<p><strong>Even parity</strong></p>
<p><strong>Odd parity</strong></p>
<p><strong>Even number of “1” bits</strong></p>
<p>0</p>
<p>1</p>
<p><strong>Odd number of “1” bits</strong></p>
<p>1</p>
<p>0</p>
<p><strong>Set parity bit to:</strong></p>
<p><strong>Even parity</strong></p>
<p><strong>Odd parity</strong></p>
<p><strong>Even number of “1” bits</strong></p>
<p>0</p>
<p>1</p>
<p><strong>Odd number of “1” bits</strong></p>
<p>1</p>
<p>0</p>
<p><em><strong>EXAMPLE</strong></em></p>
<p>Eight bits of original data, 11110000, are transmitted using even parity. To determine the parity bit (the ninth bit of data), count the number of “1” bits in the data string. In this case, there are four “1” bits. Because the total number of “1” bits is four, the data is even. Therefore, the parity bit is set to 0.</p>
<p><img alt="" height="83" src="./../images/6-7.png" width="408"/></p>
<p><strong>奇偶校驗和ECC</strong></p>
<p>奇偶校驗用於執行基本的錯誤檢查並確保記憶體內容可靠。此記憶體比非奇偶校驗慢，但增加了伺服器和某些桌上型電腦工作站所需的可靠性。</p>
<p>奇偶校驗是一種檢測記憶體錯誤相當簡單的方法，沒有任何校正功能。奇偶校驗在添加到傳輸數據字符串的單個數據位中表示。如果模組通常具有七個數據位，則將八分之一添加為奇偶校驗位。如果模組通常有八個芯片用於數據，則添加第九個芯片以實現奇偶校驗。</p>
<p>每個字節都有一個與之關聯的奇偶校驗位。在七位組成原始數據的情況下，總共傳輸了八位（七位原始數據位加一個奇偶校驗位）。在八位組成原始數據的情況下，總共傳輸九位（八位數據位加一位奇偶校驗位）。奇偶校驗位在寫入時設置，然後在讀取時進行計算和比較，以確定自存儲資料以來是否有任何位發生了更改。這種類型的檢查僅限於檢測單個位錯誤。如果更改了兩位，則將“通過”奇偶校驗，並且允許該錯誤可能損壞資料。</p>
<p>奇偶校驗可以實現為“ 0”奇偶校驗或“ 1”奇偶校驗。存儲字節時，將加零（如果選擇了“ 1”奇偶校驗，則為零）的數目。結果存儲在奇偶校驗位中-如果為奇數，則為“ 1”；如果為偶數，則為“ 0”。從記憶體中讀取該字節後，將再次對這些位進行計數，並將結果與奇偶校驗位中存儲的結果進行比較。匹配表示資料從存儲時起就沒有改變（或以結果相同的方式更改了兩位）。</p>
<p>不管發送的原始數據位數是多少，確定奇偶校驗位的過程都是相同的。通常，原始資料有七位或八位。</p>
<p>奇偶校驗位是通過對數據字符串中“ 1”位的數量進行計數來確定的。</p>
<p><em><strong>範例</strong></em></p>
<p>使用偶校驗發送八位原始數據11110000。 要確定奇偶校驗位（數據的第9位），請計算數據字符串中“ 1”位的數量。 在這種情況下，有四個“ 1”位。 因為“ 1”位的總數是四，所以數據是偶數。 因此，奇偶校驗位設置為0。</p>
<p></p>
<p><em><strong>EXAMPLE</strong></em></p>
<p>Seven bits of original data, 1000010, are transmitted using odd parity. To determine the parity bit (the eighth bit of data), count the number of “1” bits in the data string. In this case, there are two “1” bits. Therefore the parity bit is set to 1, because the total number of “1” bits (two) in the data is even, which does not match the odd parity of the transmission. Because of the mismatch in the number of “1” bits and the parity setting (odd), the parity bit must be set to 1. Because the total number of “1” bits is two, adding a parity bit of “1” to the string will result in an odd number of “1” bits (three) in the full eight-bit string (seven data bits plus one parity bit).</p>
<p><img alt="" height="83" src="./../images/6-8.png" width="486"/></p>
<p><em><strong>範例</strong></em></p>
<p>使用奇偶校驗傳輸七位原始數據1000010。 要確定奇偶校驗位（數據的第八位），請計算數據字符串中“ 1”位的數量。 在這種情況下，有兩個“ 1”位。 因此，將奇偶校驗位設置為1，因為數據中“ 1”位（兩個）的總數為偶數，這與傳輸的奇數奇偶校驗不匹配。 由於“ 1”位的數量和奇偶校驗設置（奇數）不匹配，因此必須將奇偶校驗位設置為1。由於“ 1”位的總數為2，因此將奇偶校驗位“ 1”添加到 該字符串將在整個八位字符串（七個數據位加一個奇偶校驗位）中產生奇數個“ 1”位（三個）。</p>
<p></p>
<p>Since about 90 percent of all <strong><em>soft errors </em></strong>are of the single bit kind, parity checking is usually quite sufficient for most situations. Unfortunately, there is a penalty to be paid for error checking, which is slightly slower performance, since there are extra clock cycles spent in calculating, storing, and fetching the parity bit. One other consideration is that since the error cannot be fixed by parity, the application must actually be stopped and an error message issued indicating that a parity error was encountered.</p>
<table>
<thead>
<tr>
<td>
<p><strong>Original data</strong></p>
</td>
<td>
<p><strong>Count of “1” bits</strong></p>
</td>
<td colspan="2">
<p><strong>Bits transmitted (8 or 9, depending on number of original bits), including parity</strong></p>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td>
<p><strong>Even Parity</strong></p>
</td>
<td>
<p><strong>Odd Parity</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<p>0000000</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>0000000<em><strong>0</strong></em></p>
</td>
<td>
<p>0000000<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>0101101</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>0101101<em><strong>0</strong></em></p>
</td>
<td>
<p>0101101<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>0101010</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>0101010<em><strong>1</strong></em></p>
</td>
<td>
<p>0101010<em><strong>0</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>10000000</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1000000<em><strong>1</strong></em></p>
</td>
<td>
<p>10000000<em><strong>0</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>11111100</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>11111100<em><strong>0</strong></em></p>
</td>
<td>
<p>11111100<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>10001100</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>10001100<em><strong>1</strong></em></p>
</td>
<td>
<p>10001100<em><strong>0</strong></em></p>
</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr>
<td></td>
</tr>
<tr>
<td>
<table>
<thead>
<tr>
<td>
<p><strong>Original data</strong></p>
</td>
<td>
<p><strong>Count of “1” bits</strong></p>
</td>
<td colspan="2">
<p><strong>Bits transmitted (8 or 9, depending on number of original bits), including parity</strong></p>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td>
<p><strong>Even Parity</strong></p>
</td>
<td>
<p><strong>Odd Parity</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<p>0000000</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>0000000<em><strong>0</strong></em></p>
</td>
<td>
<p>0000000<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>0101101</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>0101101<em><strong>0</strong></em></p>
</td>
<td>
<p>0101101<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>0101010</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>0101010<em><strong>1</strong></em></p>
</td>
<td>
<p>0101010<em><strong>0</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>10000000</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1000000<em><strong>1</strong></em></p>
</td>
<td>
<p>10000000<em><strong>0</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>11111100</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>11111100<em><strong>0</strong></em></p>
</td>
<td>
<p>11111100<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>10001100</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>10001100<em><strong>1</strong></em></p>
</td>
<td>
<p>10001100<em><strong>0</strong></em></p>
</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr>
<td></td>
</tr>
<tr>
<td>
<table>
<thead>
<tr>
<td>
<p><strong>Original data</strong></p>
</td>
<td>
<p><strong>Count of “1” bits</strong></p>
</td>
<td colspan="2">
<p><strong>Bits transmitted (8 or 9, depending on number of original bits), including parity</strong></p>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td>
<p><strong>Even Parity</strong></p>
</td>
<td>
<p><strong>Odd Parity</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<p>0000000</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>0000000<em><strong>0</strong></em></p>
</td>
<td>
<p>0000000<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>0101101</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>0101101<em><strong>0</strong></em></p>
</td>
<td>
<p>0101101<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>0101010</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>0101010<em><strong>1</strong></em></p>
</td>
<td>
<p>0101010<em><strong>0</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>10000000</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1000000<em><strong>1</strong></em></p>
</td>
<td>
<p>10000000<em><strong>0</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>11111100</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>11111100<em><strong>0</strong></em></p>
</td>
<td>
<p>11111100<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>10001100</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>10001100<em><strong>1</strong></em></p>
</td>
<td>
<p>10001100<em><strong>0</strong></em></p>
</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<td>
<p><strong>Original data</strong></p>
</td>
<td>
<p><strong>Count of “1” bits</strong></p>
</td>
<td colspan="2">
<p><strong>Bits transmitted (8 or 9, depending on number of original bits), including parity</strong></p>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td>
<p><strong>Even Parity</strong></p>
</td>
<td>
<p><strong>Odd Parity</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<p>0000000</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>0000000<em><strong>0</strong></em></p>
</td>
<td>
<p>0000000<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>0101101</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>0101101<em><strong>0</strong></em></p>
</td>
<td>
<p>0101101<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>0101010</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>0101010<em><strong>1</strong></em></p>
</td>
<td>
<p>0101010<em><strong>0</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>10000000</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1000000<em><strong>1</strong></em></p>
</td>
<td>
<p>10000000<em><strong>0</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>11111100</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>11111100<em><strong>0</strong></em></p>
</td>
<td>
<p>11111100<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>10001100</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>10001100<em><strong>1</strong></em></p>
</td>
<td>
<p>10001100<em><strong>0</strong></em></p>
</td>
</tr>
</tbody>
</table>
<p><strong>Original data</strong></p>
<p><strong>Count of “1” bits</strong></p>
<p><strong>Bits transmitted (8 or 9, depending on number of original bits), including parity</strong></p>
<p><strong>Even Parity</strong></p>
<p><strong>Odd Parity</strong></p>
<p>0000000</p>
<p>0</p>
<p>0000000<em><strong>0</strong></em></p>
<p>0000000<em><strong>1</strong></em></p>
<p>0101101</p>
<p>4</p>
<p>0101101<em><strong>0</strong></em></p>
<p>0101101<em><strong>1</strong></em></p>
<p>0101010</p>
<p>3</p>
<p>0101010<em><strong>1</strong></em></p>
<p>0101010<em><strong>0</strong></em></p>
<p>10000000</p>
<p>1</p>
<p>1000000<em><strong>1</strong></em></p>
<p>10000000<em><strong>0</strong></em></p>
<p>11111100</p>
<p>6</p>
<p>11111100<em><strong>0</strong></em></p>
<p>11111100<em><strong>1</strong></em></p>
<p>10001100</p>
<p>3</p>
<p>10001100<em><strong>1</strong></em></p>
<p>10001100<em><strong>0</strong></em></p>
<table>
<thead>
<tr>
<td>
<p><strong>Original data</strong></p>
</td>
<td>
<p><strong>Count of “1” bits</strong></p>
</td>
<td colspan="2">
<p><strong>Bits transmitted (8 or 9, depending on number of original bits), including parity</strong></p>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td>
<p><strong>Even Parity</strong></p>
</td>
<td>
<p><strong>Odd Parity</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<p>0000000</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>0000000<em><strong>0</strong></em></p>
</td>
<td>
<p>0000000<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>0101101</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>0101101<em><strong>0</strong></em></p>
</td>
<td>
<p>0101101<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>0101010</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>0101010<em><strong>1</strong></em></p>
</td>
<td>
<p>0101010<em><strong>0</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>10000000</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1000000<em><strong>1</strong></em></p>
</td>
<td>
<p>10000000<em><strong>0</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>11111100</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>11111100<em><strong>0</strong></em></p>
</td>
<td>
<p>11111100<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>10001100</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>10001100<em><strong>1</strong></em></p>
</td>
<td>
<p>10001100<em><strong>0</strong></em></p>
</td>
</tr>
</tbody>
</table>
<p><strong>Original data</strong></p>
<p><strong>Count of “1” bits</strong></p>
<p><strong>Bits transmitted (8 or 9, depending on number of original bits), including parity</strong></p>
<p><strong>Even Parity</strong></p>
<p><strong>Odd Parity</strong></p>
<p>0000000</p>
<p>0</p>
<p>0000000<em><strong>0</strong></em></p>
<p>0000000<em><strong>1</strong></em></p>
<p>0101101</p>
<p>4</p>
<p>0101101<em><strong>0</strong></em></p>
<p>0101101<em><strong>1</strong></em></p>
<p>0101010</p>
<p>3</p>
<p>0101010<em><strong>1</strong></em></p>
<p>0101010<em><strong>0</strong></em></p>
<p>10000000</p>
<p>1</p>
<p>1000000<em><strong>1</strong></em></p>
<p>10000000<em><strong>0</strong></em></p>
<p>11111100</p>
<p>6</p>
<p>11111100<em><strong>0</strong></em></p>
<p>11111100<em><strong>1</strong></em></p>
<p>10001100</p>
<p>3</p>
<p>10001100<em><strong>1</strong></em></p>
<p>10001100<em><strong>0</strong></em></p>
<p><strong>Original data</strong></p>
<p><strong>Count of “1” bits</strong></p>
<p><strong>Bits transmitted (8 or 9, depending on number of original bits), including parity</strong></p>
<p><strong>Even Parity</strong></p>
<p><strong>Odd Parity</strong></p>
<p>0000000</p>
<p>0</p>
<p>0000000<em><strong>0</strong></em></p>
<p>0000000<em><strong>1</strong></em></p>
<p>0101101</p>
<p>4</p>
<p>0101101<em><strong>0</strong></em></p>
<p>0101101<em><strong>1</strong></em></p>
<p>0101010</p>
<p>3</p>
<p>0101010<em><strong>1</strong></em></p>
<p>0101010<em><strong>0</strong></em></p>
<p>10000000</p>
<p>1</p>
<p>1000000<em><strong>1</strong></em></p>
<p>10000000<em><strong>0</strong></em></p>
<p>11111100</p>
<p>6</p>
<p>11111100<em><strong>0</strong></em></p>
<p>11111100<em><strong>1</strong></em></p>
<p>10001100</p>
<p>3</p>
<p>10001100<em><strong>1</strong></em></p>
<p>10001100<em><strong>0</strong></em></p>
<table>
<thead>
<tr>
<td>
<p><strong>Original data</strong></p>
</td>
<td>
<p><strong>Count of “1” bits</strong></p>
</td>
<td colspan="2">
<p><strong>Bits transmitted (8 or 9, depending on number of original bits), including parity</strong></p>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td>
<p><strong>Even Parity</strong></p>
</td>
<td>
<p><strong>Odd Parity</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<p>0000000</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>0000000<em><strong>0</strong></em></p>
</td>
<td>
<p>0000000<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>0101101</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>0101101<em><strong>0</strong></em></p>
</td>
<td>
<p>0101101<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>0101010</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>0101010<em><strong>1</strong></em></p>
</td>
<td>
<p>0101010<em><strong>0</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>10000000</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1000000<em><strong>1</strong></em></p>
</td>
<td>
<p>10000000<em><strong>0</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>11111100</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>11111100<em><strong>0</strong></em></p>
</td>
<td>
<p>11111100<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>10001100</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>10001100<em><strong>1</strong></em></p>
</td>
<td>
<p>10001100<em><strong>0</strong></em></p>
</td>
</tr>
</tbody>
</table>
<p><strong>Original data</strong></p>
<p><strong>Count of “1” bits</strong></p>
<p><strong>Bits transmitted (8 or 9, depending on number of original bits), including parity</strong></p>
<p><strong>Even Parity</strong></p>
<p><strong>Odd Parity</strong></p>
<p>0000000</p>
<p>0</p>
<p>0000000<em><strong>0</strong></em></p>
<p>0000000<em><strong>1</strong></em></p>
<p>0101101</p>
<p>4</p>
<p>0101101<em><strong>0</strong></em></p>
<p>0101101<em><strong>1</strong></em></p>
<p>0101010</p>
<p>3</p>
<p>0101010<em><strong>1</strong></em></p>
<p>0101010<em><strong>0</strong></em></p>
<p>10000000</p>
<p>1</p>
<p>1000000<em><strong>1</strong></em></p>
<p>10000000<em><strong>0</strong></em></p>
<p>11111100</p>
<p>6</p>
<p>11111100<em><strong>0</strong></em></p>
<p>11111100<em><strong>1</strong></em></p>
<p>10001100</p>
<p>3</p>
<p>10001100<em><strong>1</strong></em></p>
<p>10001100<em><strong>0</strong></em></p>
<p><strong>Original data</strong></p>
<p><strong>Count of “1” bits</strong></p>
<p><strong>Bits transmitted (8 or 9, depending on number of original bits), including parity</strong></p>
<p><strong>Even Parity</strong></p>
<p><strong>Odd Parity</strong></p>
<p>0000000</p>
<p>0</p>
<p>0000000<em><strong>0</strong></em></p>
<p>0000000<em><strong>1</strong></em></p>
<p>0101101</p>
<p>4</p>
<p>0101101<em><strong>0</strong></em></p>
<p>0101101<em><strong>1</strong></em></p>
<p>0101010</p>
<p>3</p>
<p>0101010<em><strong>1</strong></em></p>
<p>0101010<em><strong>0</strong></em></p>
<p>10000000</p>
<p>1</p>
<p>1000000<em><strong>1</strong></em></p>
<p>10000000<em><strong>0</strong></em></p>
<p>11111100</p>
<p>6</p>
<p>11111100<em><strong>0</strong></em></p>
<p>11111100<em><strong>1</strong></em></p>
<p>10001100</p>
<p>3</p>
<p>10001100<em><strong>1</strong></em></p>
<p>10001100<em><strong>0</strong></em></p>
<p><strong>Original data</strong></p>
<p><strong>Count of “1” bits</strong></p>
<p><strong>Bits transmitted (8 or 9, depending on number of original bits), including parity</strong></p>
<p><strong>Even Parity</strong></p>
<p><strong>Odd Parity</strong></p>
<p>0000000</p>
<p>0</p>
<p>0000000<em><strong>0</strong></em></p>
<p>0000000<em><strong>1</strong></em></p>
<p>0101101</p>
<p>4</p>
<p>0101101<em><strong>0</strong></em></p>
<p>0101101<em><strong>1</strong></em></p>
<p>0101010</p>
<p>3</p>
<p>0101010<em><strong>1</strong></em></p>
<p>0101010<em><strong>0</strong></em></p>
<p>10000000</p>
<p>1</p>
<p>1000000<em><strong>1</strong></em></p>
<p>10000000<em><strong>0</strong></em></p>
<p>11111100</p>
<p>6</p>
<p>11111100<em><strong>0</strong></em></p>
<p>11111100<em><strong>1</strong></em></p>
<p>10001100</p>
<p>3</p>
<p>10001100<em><strong>1</strong></em></p>
<p>10001100<em><strong>0</strong></em></p>
<p><span>Original data (seven or eight bits) and the corresponding parity bit for even and odd parity.</span></p>
<p>Error Correcting Code (ECC), takes the parity concept a step further by not only identifying the error, but also correcting the issue. To determine if the data has been corrected or changed from the original data as a result of parity, examine the full transmitted data string, including the parity bit.</p>
<p><em><strong>EXAMPLE</strong></em></p>
<p>111100000 is transmitted using even parity. To determine if the memory has been changed across the transmission, count the number of “1” bits in the data string, including the parity bit. In this case, there are four “1” bits. Because the total number of “1” bits (four) in the data is even, which matches the even parity of the transmission, no memory has been changed.</p>
<p> <img alt="" height="42" src="./../images/6-9.png" width="295"/></p>
<p></p>
<p>由於所有軟體錯誤中約有90％是單位原類型的，因此奇偶校驗通常在大多數情況下就足夠了。 不幸的是，由於要花費額外的時間週期來計算、存儲和讀取奇偶校驗位，因此錯誤檢查要付出一定的代價，這會稍微降低性能。 另一個考慮因素是，由於無法通過奇偶校驗解決錯誤，因此實際上必須停止應用程序，並發出一條錯誤消息，指出遇到奇偶校驗錯誤。</p>
<table>
<thead>
<tr>
<td>
<p><strong>原始資料</strong></p>
</td>
<td>
<p><strong>“ 1</strong><strong>”位的計數</strong></p>
</td>
<td colspan="2">
<p><strong>傳輸的位元（8</strong><strong>位或9</strong><strong>位，取決於原始位元的數量），包括奇偶校驗</strong></p>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td>
<p><strong>偶校驗</strong></p>
</td>
<td>
<p><strong>奇校驗</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<p>0000000</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>0000000<em><strong>0</strong></em></p>
</td>
<td>
<p>0000000<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>0101101</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>0101101<em><strong>0</strong></em></p>
</td>
<td>
<p>0101101<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>0101010</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>0101010<em><strong>1</strong></em></p>
</td>
<td>
<p>0101010<em><strong>0</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>10000000</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1000000<em><strong>1</strong></em></p>
</td>
<td>
<p>10000000<em><strong>0</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>11111100</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>11111100<em><strong>0</strong></em></p>
</td>
<td>
<p>11111100<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>10001100</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>10001100<em><strong>1</strong></em></p>
</td>
<td>
<p>10001100<em><strong>0</strong></em></p>
</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<td>
<p><strong>原始資料</strong></p>
</td>
<td>
<p><strong>“ 1</strong><strong>”位的計數</strong></p>
</td>
<td colspan="2">
<p><strong>傳輸的位元（8</strong><strong>位或9</strong><strong>位，取決於原始位元的數量），包括奇偶校驗</strong></p>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td>
<p><strong>偶校驗</strong></p>
</td>
<td>
<p><strong>奇校驗</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<p>0000000</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>0000000<em><strong>0</strong></em></p>
</td>
<td>
<p>0000000<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>0101101</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>0101101<em><strong>0</strong></em></p>
</td>
<td>
<p>0101101<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>0101010</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>0101010<em><strong>1</strong></em></p>
</td>
<td>
<p>0101010<em><strong>0</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>10000000</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>1000000<em><strong>1</strong></em></p>
</td>
<td>
<p>10000000<em><strong>0</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>11111100</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>11111100<em><strong>0</strong></em></p>
</td>
<td>
<p>11111100<em><strong>1</strong></em></p>
</td>
</tr>
<tr>
<td>
<p>10001100</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>10001100<em><strong>1</strong></em></p>
</td>
<td>
<p>10001100<em><strong>0</strong></em></p>
</td>
</tr>
</tbody>
</table>
<p><strong>原始資料</strong></p>
<p><strong>“ 1</strong><strong>”位的計數</strong></p>
<p><strong>傳輸的位元（8</strong><strong>位或9</strong><strong>位，取決於原始位元的數量），包括奇偶校驗</strong></p>
<p><strong>偶校驗</strong></p>
<p><strong>奇校驗</strong></p>
<p>0000000</p>
<p>0</p>
<p>0000000<em><strong>0</strong></em></p>
<p>0000000<em><strong>1</strong></em></p>
<p>0101101</p>
<p>4</p>
<p>0101101<em><strong>0</strong></em></p>
<p>0101101<em><strong>1</strong></em></p>
<p>0101010</p>
<p>3</p>
<p>0101010<em><strong>1</strong></em></p>
<p>0101010<em><strong>0</strong></em></p>
<p>10000000</p>
<p>1</p>
<p>1000000<em><strong>1</strong></em></p>
<p>10000000<em><strong>0</strong></em></p>
<p>11111100</p>
<p>6</p>
<p>11111100<em><strong>0</strong></em></p>
<p>11111100<em><strong>1</strong></em></p>
<p>10001100</p>
<p>3</p>
<p>10001100<em><strong>1</strong></em></p>
<p>10001100<em><strong>0</strong></em></p>
<p><strong>原始資料</strong></p>
<p><strong>“ 1</strong><strong>”位的計數</strong></p>
<p><strong>傳輸的位元（8</strong><strong>位或9</strong><strong>位，取決於原始位元的數量），包括奇偶校驗</strong></p>
<p><strong>偶校驗</strong></p>
<p><strong>奇校驗</strong></p>
<p>0000000</p>
<p>0</p>
<p>0000000<em><strong>0</strong></em></p>
<p>0000000<em><strong>1</strong></em></p>
<p>0101101</p>
<p>4</p>
<p>0101101<em><strong>0</strong></em></p>
<p>0101101<em><strong>1</strong></em></p>
<p>0101010</p>
<p>3</p>
<p>0101010<em><strong>1</strong></em></p>
<p>0101010<em><strong>0</strong></em></p>
<p>10000000</p>
<p>1</p>
<p>1000000<em><strong>1</strong></em></p>
<p>10000000<em><strong>0</strong></em></p>
<p>11111100</p>
<p>6</p>
<p>11111100<em><strong>0</strong></em></p>
<p>11111100<em><strong>1</strong></em></p>
<p>10001100</p>
<p>3</p>
<p>10001100<em><strong>1</strong></em></p>
<p>10001100<em><strong>0</strong></em></p>
<p><strong>原始資料</strong></p>
<p><strong>“ 1</strong><strong>”位的計數</strong></p>
<p><strong>傳輸的位元（8</strong><strong>位或9</strong><strong>位，取決於原始位元的數量），包括奇偶校驗</strong></p>
<p><strong>偶校驗</strong></p>
<p><strong>奇校驗</strong></p>
<p>0000000</p>
<p>0</p>
<p>0000000<em><strong>0</strong></em></p>
<p>0000000<em><strong>1</strong></em></p>
<p>0101101</p>
<p>4</p>
<p>0101101<em><strong>0</strong></em></p>
<p>0101101<em><strong>1</strong></em></p>
<p>0101010</p>
<p>3</p>
<p>0101010<em><strong>1</strong></em></p>
<p>0101010<em><strong>0</strong></em></p>
<p>10000000</p>
<p>1</p>
<p>1000000<em><strong>1</strong></em></p>
<p>10000000<em><strong>0</strong></em></p>
<p>11111100</p>
<p>6</p>
<p>11111100<em><strong>0</strong></em></p>
<p>11111100<em><strong>1</strong></em></p>
<p>10001100</p>
<p>3</p>
<p>10001100<em><strong>1</strong></em></p>
<p>10001100<em><strong>0</strong></em></p>
<p>偵錯碼（ECC）使奇偶校驗概念更進一步，不僅可以識別錯誤，還可以糾正問題。 要確定是否由於奇偶校驗而對原始數據進行了校正或更改，請檢查完整的傳輸資料字符串，包括奇偶校驗位。</p>
<p><em><strong>範例</strong></em></p>
<p>使用偶校驗發送111100000。 要確定在傳輸過程中記憶體是否已被更改，請計算數據字符串中包括奇偶校驗位的“ 1”位數。 在這種情況下，有四個“ 1”位。 由於數據中的“ 1”位（四位）總數為偶數，與傳輸的偶數奇偶校驗相匹配，因此無任何記憶體被更改。</p>
<p></p>
<p><em><strong>EXAMPLE</strong></em></p>
<p>10000100 is transmitted using odd parity. To determine if the memory has been changed across the transmission, count the number of “1” bits in the data string, including the parity bit. In this case, there are two “1” bits. The total number of “1” bits (two) in the data is even, which does not match the odd parity of the transmission. Therefore, memory has been changed.</p>
<p style="line-height: 18.0pt; background: white; vertical-align: baseline; margin: 6.0pt 0cm 9.6pt 0cm;"><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Georgia',serif; color: #241d1d;"><img alt="" height="42" src="./../images/6-11.png" width="292"/></span></p>
<p style="line-height: 18.0pt; background: white; vertical-align: baseline; margin: 6.0pt 0cm 9.6pt 0cm;"><img alt="" height="42" src="./../images/6-10.png" width="295"/></p>
<p><em><strong>範例</strong></em></p>
<p>使用奇偶校驗發送10000100。 要確定在傳輸過程中記憶體是否被更改，請計算數據字符串中包括奇偶校驗位的“ 1”位數。 在這種情況下，有兩個“ 1”位。 資料中“ 1”位的總數（兩個）是偶數，與傳輸的奇數奇偶校驗不匹配。 因此，記憶體已被更改。</p>
<p><strong><em>Single-Sided and Double-Sided Memory</em></strong></p>
<p style="line-height: 18.0pt; background: white; vertical-align: baseline; margin: 6.0pt 0cm 9.6pt 0cm;"><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Georgia',serif; color: #241d1d;">Memory can be single-sided or double-sided. The benefit of double-sided modules is that a higher amount of storage can fit on a single chip and into a single slot. Some motherboards support double-sided SIMMs, but others do not, so it is important to check the motherboard’s manual for guidance. To determine if the module is double-sided, simply look at both sides. If chips are soldered on both sides, it is a double-sided SIMM.<o:p></o:p></span></p>
<p style="line-height: 18.0pt; background: white; vertical-align: baseline; margin: 6.0pt 0cm 9.6pt 0cm;"><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Georgia',serif; color: #241d1d;">Memory can be single-sided or double-sided. The benefit of double-sided modules is that a higher amount of storage can fit on a single chip and into a single slot. Some motherboards support double-sided SIMMs, but others do not, so it is important to check the motherboard’s manual for guidance. To determine if the module is double-sided, simply look at both sides. If chips are soldered on both sides, it is a double-sided SIMM.<o:p></o:p></span></p>
<p>單面和雙面記憶體</p>
<p>記憶體可以是單面或雙面的。 雙面模組的好處在於，單個芯片和單個插槽中可以容納更多的存儲空間。 有些主機板支持雙面SIMM，而另一些則不支持，因此查看主機板的手冊以獲取指示很重要。 要確定模組是否雙面，只需查看一下雙面即可。 如果芯片的兩面都焊接，則為雙面SIMM。</p>
<p> </p>
<p><em><strong>Installing Memory Modules</strong></em></p>
<p>Installing memory is a common computer upgrade and a very easy task to perform. Memory modules are installed as “sticks” (or modules) of memory into the “slots” on the motherboard.</p>
<p><img alt="" height="241" src="./../images/6-13.png" width="362"/></p>
<p><img alt="" height="360" src="./../images/6-13.png" width="540"/></p>
<p>安裝記憶體模組</p>
<p>安裝記憶體是電腦的常見升級，並且是很容易執行的。 記憶體模組作為記憶體的“棒”（或模組）安裝在主板上的“插槽”中。</p>
<p></p>
<p>The process of installing memory sticks is fairly easy, but caution and precision are necessary. To install memory sticks (or modules):</p>
<ol>
<li>Always ensure you take proper ESD (electrostatic discharge) protection measures to ensure both the motherboard and memory modules are not harmed during installation.</li>
<li>Turn off the computer and unplug the power cord.</li>
<li>Open the case and begin the installation of the memory sticks. Always hold the memory sticks by the sides of the chips and never by the gold contacts.</li>
<li>Line up the memory module’s connector with the slot on the motherboard.</li>
<li>Verify that the locking tabs are in the open position.</li>
<li>Push the module straight down until the tabs swivel to the locking position (this takes force).</li>
</ol>
<ol>
<li>Always ensure you take proper ESD (electrostatic discharge) protection measures to ensure both the motherboard and memory modules are not harmed during installation.</li>
<li>Turn off the computer and unplug the power cord.</li>
<li>Open the case and begin the installation of the memory sticks. Always hold the memory sticks by the sides of the chips and never by the gold contacts.</li>
<li>Line up the memory module’s connector with the slot on the motherboard.</li>
<li>Verify that the locking tabs are in the open position.</li>
<li>Push the module straight down until the tabs swivel to the locking position (this takes force).</li>
</ol>
<p>Important note: Never touch the gold connectors on the modules! Corrosion of the contacts can occur, or the module may be damaged due to electrostatic discharge.</p>
<p>To explore more about how to install RAM, visit <a href="http://www.wikihow.com/Install-RAM">www.wikihow.com/Install-RAM</a>.</p>
<p> </p>
<p>安裝記憶體的過程相當容易，但是必須謹慎且精確。 要安裝記憶體（或模組）：</p>
<p>1.始終確保採取適當的ESD（靜電釋放）保護措施，以確保在安裝過程中不會損壞主機板和記憶體模組。</p>
<p>2.關閉電腦，然後拔下電源線。</p>
<p>3.打開盒子，開始安裝記憶體。 始終將記憶體放在芯片的側面，而不要緊握金屬接點。</p>
<p>4.將記憶體模組的連接器與主機板上的插槽對齊。</p>
<p>5.確認鎖定卡榫處於打開位置。</p>
<p>6.垂直向下推動模組，直到卡榫旋轉到鎖定位置（這需要用力）。</p>
<p>重要說明：切勿觸摸模組上的金色接點！ 接點可能會腐蝕，或者由於靜電放電會損壞模塊。</p>
<p>要了解有關如何安裝RAM的更多信息，請搜尋www.wikihow.com/Install-RAM。</p>
<p> </p>
<p><em><strong>Introduction to BIOS, CMOS, and Firmware</strong></em></p>
<p>When a computer is turned on, the computer’s microprocessor uses a program called the <em><strong>BIOS</strong></em> (basic input/output system) to start the computer system. The BIOS also manages data flow between the computer's operating system and attached/connected devices, such as the hard drive, video adapter, keyboard, mouse, and printer.</p>
<p><img alt="" height="324" src="./../images/6-14.png" width="433"/></p>
<p>BIOS，CMOS和韌體簡介</p>
<p>開啟電腦後，電腦的微處理器會使用稱為BIOS（基本輸入/輸出系統）的程序來啟動電腦系統。 BIOS還管理電腦操作系統和已連接/已連接的設備（例如硬碟、影像連接器、鍵盤、滑鼠和打印機）之間的資訊流。</p>
<p></p>
<p style="margin: 0cm; line-height: 18.0pt; background: white; vertical-align: baseline;"><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Georgia',serif; color: #241d1d;">A computer’s BIOS is the most common example of </span><span class="term"><b><i><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Georgia',serif; color: #709e30;">firmware</span></i></b></span><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Georgia',serif; color: #241d1d;">. Firmware is software on a chip, and is the first software run by the computer when the machine is booted up. The BIOS has several roles, including performing the power-on self-test, which tests and initializes the processor, video card, disk drives, and adapters. The BIOS also includes the low-level “operating system” for the computer, which allows the computer to take input from and give output to the most basic components, including the keyboard, mouse, and disk drives. The BIOS is stored in a ROM (Read-only memory) chip, but can be upgraded through a process call “flashing.”<o:p></o:p></span></p>
<p style="margin: 0cm; line-height: 18.0pt; background: white; vertical-align: baseline;"><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Georgia',serif; color: #241d1d;">While the BIOS is a program that allows the user to make changes to the settings, the settings themselves are stored in the complementary metal-oxide semiconductor, or </span><span class="term"><b><i><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Georgia',serif; color: #709e30;">CMOS</span></i></b></span><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Georgia',serif; color: #241d1d;">. The CMOS is a battery-powered memory chip.<o:p></o:p></span></p>
<p style="margin: 0cm; line-height: 18.0pt; background: white; vertical-align: baseline;"><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Georgia',serif; color: #241d1d;"></span></p>
<p>電腦的BIOS是最常見的韌體示例。 韌體是芯片上的軟體，是韌體啟動時電腦運行的第一個軟體。 BIOS具有多個角色，包括執行開機自檢，該自檢將測試並初始化處理器，顯示卡，磁碟驅動器和連接器。 BIOS還包括用於電腦的基本“操作系統”，它使電腦可以從最基本的組件（包括鍵盤，滑鼠和磁碟驅動器）獲取輸入並提供輸出。 BIOS存儲在ROM（唯讀記憶體）芯片中，但可以通過過程調用“刷新”進行升級。</p>
<p>BIOS是允許用戶更改設置的程序，而設置本身則存儲在互補金屬氧化物半導體或CMOS中。 CMOS是電池供電的存儲芯片。</p>
<p><em><strong>Understanding BIOS and CMOS</strong></em></p>
<p>The BIOS is used to configure common settings, such as the order in which devices are read by the computer. This order is known as the boot order. In addition, the BIOS is also used in the configuration of settings that turn on and off various input/output ports, and the configuration of various CPU settings such as<strong><em>virtualization</em></strong> and <strong><em>overclocking</em></strong> .</p>
<p>Be very careful when making changes to the BIOS. Incorrect settings may keep your computer from booting.</p>
<p><img alt="" height="201" src="./../images/6-15.png" width="298"/></p>
<p><img alt="" height="297" src="./../images/6-15.png" width="440"/></p>
<p>了解BIOS和CMOS</p>
<p>BIOS用於配置通用設定，例如電腦讀取設備的順序。 此命令稱為引導命令。 此外，BIOS還用於配置打開和關閉各種輸入/輸出端口的設定，以及各種CPU設置（例如虛擬化和超頻）的配定。</p>
<p>更改BIOS時要非常小心。 不正確的設置可能會使您的電腦無法啟動。</p>
<p></p>
<p>BIOS configures the following settings:</p>
<ul>
<li>Boot order</li>
<li>Storage devices (USB drives, hard drives, floppy drives, optical drives)</li>
<li>Built-in ports (SATA, eSATA, PATA, USB, IEEE-1394, serial, parallel, PS/2)</li>
<li>AGP, PCI, PCIe slots</li>
<li>Integrated chipsets (audio, video, network)</li>
<li>Virtualization</li>
<li>Clock speed</li>
<li>Memory (RAM)</li>
<li>Power management</li>
<li>Intrusion detection</li>
<li>Passwords and encryption</li>
<li>PC health tools (temperature, voltage, etc.)</li>
<li>Direct access to the web or other services without booting computer (UEFI specific)</li>
</ul>
<ul>
<li>Boot order</li>
<li>Storage devices (USB drives, hard drives, floppy drives, optical drives)</li>
<li>Built-in ports (SATA, eSATA, PATA, USB, IEEE-1394, serial, parallel, PS/2)</li>
<li>AGP, PCI, PCIe slots</li>
<li>Integrated chipsets (audio, video, network)</li>
<li>Virtualization</li>
<li>Clock speed</li>
<li>Memory (RAM)</li>
<li>Power management</li>
<li>Intrusion detection</li>
<li>Passwords and encryption</li>
<li>PC health tools (temperature, voltage, etc.)</li>
<li>Direct access to the web or other services without booting computer (UEFI specific)</li>
</ul>
<p>When the power button is pressed on the computer, the first step in the boot process is the power-on self-test, called the <strong><em>POST</em></strong>. Once a successful POST occurs, the BIOS reads the settings from the CMOS, and the BIOS looks for an operating system from the configured boot devices. Once it finds the operating system, the operating system’s boot loader begins the operating system boot process, and turns over control of the computer to the operating system.</p>
<p><img alt="" height="186" src="./../images/6-16.png" width="346"/></p>
<p><img alt="" height="298" src="./../images/6-16.png" width="554"/></p>
<p>BIOS配置以下設置：</p>
<ul>
<li>啟動順序</li>
<li>儲存設備（USB驅動器，硬碟驅動器，軟碟驅動器，光碟驅動器）</li>
<li>內置街口（SATA，eSATA，PATA，USB，IEEE-1394，串行，並行，PS / 2）</li>
<li>AGP，PCI，PCIe插槽</li>
<li>集成芯片組（音頻，視頻，網絡）</li>
<li>虛擬化</li>
<li>時脈速度</li>
<li>記憶體（RAM）</li>
<li>能源管理</li>
<li>入侵檢測</li>
<li>密碼和加密</li>
<li>PC健康工具（溫度，電壓等）</li>
<li>直接讀取Web或其他服務，而無需啟動電腦（特定於UEFI）</li>
</ul>
<ul>
<li>啟動順序</li>
<li>儲存設備（USB驅動器，硬碟驅動器，軟碟驅動器，光碟驅動器）</li>
<li>內置街口（SATA，eSATA，PATA，USB，IEEE-1394，串行，並行，PS / 2）</li>
<li>AGP，PCI，PCIe插槽</li>
<li>集成芯片組（音頻，視頻，網絡）</li>
<li>虛擬化</li>
<li>時脈速度</li>
<li>記憶體（RAM）</li>
<li>能源管理</li>
<li>入侵檢測</li>
<li>密碼和加密</li>
<li>PC健康工具（溫度，電壓等）</li>
<li>直接讀取Web或其他服務，而無需啟動電腦（特定於UEFI）</li>
</ul>
<p>當按下計電腦上的電源按鈕時，引導過程的第一步是開機自檢，稱為POST。成功進行POST後，BIOS從CMOS讀取設定，BIOS從配置的啟動設備中查找操作系統。找到操作系統後，操作系統的啟動加載程序將開始進行操作系統啟動過程，並將電腦的控制權移交給系統。</p>
<p> </p>
<p>The boot process:</p>
<ol>
<li>Power on computer.</li>
<li>BIOS performs power-on self-test (POST).</li>
<li>BIOS reads settings from CMOS.</li>
<li>BIOS looks for operating system from configured boot device.</li>
</ol>
<ol>
<li>Power on computer.</li>
<li>BIOS performs power-on self-test (POST).</li>
<li>BIOS reads settings from CMOS.</li>
<li>BIOS looks for operating system from configured boot device.</li>
</ol>
<p>啟動過程：</p>
<p>      1.開啟電腦電源。</p>
<ol start="2">
<li>BIOS執行開機自檢（POST）。</li>
<li>BIOS從CMOS讀取設定。</li>
</ol>
<ol start="2">
<li>BIOS執行開機自檢（POST）。</li>
<li>BIOS從CMOS讀取設定。</li>
</ol>
<p>      4. BIOS從配置的啟動設備中尋找系統。</p>
<p><em><strong>CMOS</strong></em></p>
<p>The CMOS (complementary metal-oxide semiconductor) is a battery-powered memory chip. It is nonvolatile memory that stores the BIOS settings and is built into the motherboard. As long as battery power remains, DC (direct current) is provided to the CMOS and allows the settings to be retained. If the computer is constantly losing the settings, the battery will need to be replaced. Older CMOS battery models used the DS12887A battery or AA-sized 3.6 volt Eternacell battery, and normally lasted approximately three years. Newer CMOS models include an internal lithium-ion battery that can last for up to 10 years. The most typical current external battery used is the CR2032, which resembles a standard watch battery. When the battery begins to fail, the first sign to the user is that the system clock frequently loses time.</p>
<p><img alt="" height="240" src="./../images/6-17.png" width="348"/></p>
<p><img alt="" height="279" src="./../images/6-17.png" width="405"/></p>
<p>CMOS（互補金屬氧化物半導體）是電池供電的存儲芯片。 它是非易失性儲存器，用於儲存BIOS設置，並內置在主機板中。 只要電池還有電，就會向CMOS提供DC（直流電）並保留設定。 如果電腦不斷丟失設定，則需要更換電池。 較舊的CMOS電池型號使用DS12887A電池或AA尺寸的3.6伏Eternacell電池，通常可以使用大約三年。 較新的CMOS型號包括內置鋰離子電池，該電池可使用長達10年。 當前使用的最典型的外部電池是CR2032，它類似於標準的手錶電池。 當電池開始出現故障時，向用戶顯示的第一個信號是系統時鐘經常失準。</p>
<p style="line-height: 18.0pt; background: white; vertical-align: baseline; margin: 6.0pt 0cm 9.6pt 0cm;"><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Georgia',serif; color: #241d1d;">To change the settings in the CMOS, the user needs to enter the BIOS. To do this, the user must press a valid key or key combination during the boot process as set by the computer manufacturer. The most common keys used to enter the BIOS are F2 and/or Delete. Typically, the keystroke required to enter the BIOS is displayed on the monitor during the boot process. If the keystroke isn’t displayed, a quick search of the manufacturer’s website will often tell the user the required keystroke to enter the BIOS.<o:p></o:p></span></p>
<p style="line-height: 18.0pt; background: white; vertical-align: baseline; margin: 6.0pt 0cm 9.6pt 0cm;"><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Georgia',serif; color: #241d1d;"><img alt="" height="278" src="./../images/6-18.png" width="337"/></span></p>
<p style="line-height: 18.0pt; background: white; vertical-align: baseline; margin: 6.0pt 0cm 9.6pt 0cm;"><img alt="" height="360" src="./../images/6-18.png" width="436"/></p>
<p>The BIOS interface and the keystrokes to enter the BIOS change depending on the BIOS manufacturer. Below are images of the BIOS interface from two different manufacturers. Notice that while the information available is consistent between the two, the interface is slightly different.</p>
<p>要更改CMOS中的設定，用戶需要進入BIOS。 為此，用戶必須在電腦製造商設置的啟動過程中按下有效的按鍵或組合鍵。 用於進入BIOS的最常用的按鍵是F2和/或Delete。 通常，在啟動過程中，進入BIOS所需的按鍵將顯示在顯示器上。 如果未顯示按鍵，則搜尋製造商的網站通常會告訴用戶進入BIOS所使用的按鍵。</p>
<p>BIOS界面和用於進入BIOS的按鍵取決於BIOS製造商。 下面是來自兩個不同製造商的BIOS接口的圖像。 請注意，儘管兩者之間的可用訊息是一致的，但界面略有不同。</p>
<p><img alt="" height="267" src="./../images/6-19.jpg" width="320"/></p>
<p><img alt="" height="418" src="./../images/6-19.jpg" width="501"/></p>
<p><img alt="" height="216" src="./../images/6-20.png" width="258"/></p>
<p><em><strong>Unified Extensible Firmware Interface (UEFI)</strong></em></p>
<p>Traditionally, there was only a single type of BIOS, which relied fully on text-based menus and the keyboard for input. More recently, most BIOS manufacturers have switched to the unified extensible firmware interface, or <span><strong><em>UEFI</em></strong></span>. This updated BIOS allows for both keyboard and mouse input, and provides a <span><strong><em>GUI </em></strong></span>instead of the standard text-based menus; support for GUID partition tables (<em><strong>GPT</strong></em>) allowing access to disks up to 2 TB and backward compatibility to legacy partition structures (such as the master boot record (<em><strong>MBR</strong></em>) and Linux's GRand Unified Bootloader (<em><strong>GRUB</strong></em>); boot from removable media; a user interface allowing for online connectivity for web access, diagnostics, and file management; and <em><strong>Secure Boot</strong></em> which protects pre-operating system code from modification. Some of these UEFI BIOS also include software that allows the user to surf the Internet, play basic games, and use backup programs without ever entering the normal operating system.</p>
<p><img alt="" height="152" src="./../images/6-21.png" width="199"/></p>
<p><strong>統一可擴展韌體接口（UEFI）</strong></p>
<p></p>
<p>傳統上，只有一種類型的BIOS，它完全依賴基於文本的選單和用於輸入的鍵盤。 最近，大多數BIOS製造商已切換到統一的可擴展韌體接口或UEFI。 此更新的BIOS允許鍵盤和滑鼠輸入，並提供GUI而不是標準的基於文本的選單。 支持GUID分區表（GPT），允許讀取最大2 TB的磁盤，並向後兼容舊分區結構（例如主啟動記錄（MBR）和Linux的GRand Unified Bootloader（GRUB）；從可移動媒體啟動；用戶界面） 允許在線連接以進行Web讀取、診斷和檔案管理；以及安全啟動（Secure Boot），可防止操作系統前代碼被修改；其中某些UEFI BIOS還包括允許用戶上網，玩基本遊戲和使用的軟體。 無需進入正常操作系統即可備份程式。</p>
<p><em><strong>Automatic Configuring of BIOS/CMOS</strong></em></p>
<p>Automatic configuration is a feature of some BIOS. While automatic BIOS configuration does not always create the most optimal settings, it can be quite useful if major errors are occurring to create a safe rollback to a known good state. Automatic configuration options include the BIOS defaults (original/failsafe settings) and setup defaults (optimal settings). There is often a turbo setup, which works toward a quick configuration for a faster system. Automatic configuration of the BIOS is often useful while troubleshooting a system.</p>
<p><img alt="" height="243" src="./../images/6-22.png" width="324"/></p>
<p><img alt="" height="271" src="./../images/6-22.png" width="362"/></p>
<p><em><strong>自動配置BIOS / CMOS</strong></em></p>
<p>自動配置是某些BIOS的功能。 儘管自動BIOS配置並非總能創建最佳設置，但是如果發生重大錯誤將安全回復創建到已知的良好狀態，它可能會非常有用。 自動配置選項包括BIOS默認設定（原始/故障安全設置）和設定默認設定（最佳設定）。 通常有一個turbo設置，可以快速配置以實現更快的系統。 在對系統進行故障排除時，BIOS的自動配置通常很有用。</p>
<p>When power is turned on, the POST (power-on self-test) is the diagnostic testing sequence that a computer's basic input/output system (or "starting program") runs to determine if the computer keyboard, random access memory, disk drives, and other hardware are working correctly. The POST is the initial test performed by the BIOS upon booting. The role of the POST is to find errors in hardware, and report those errors. The POST checks the following:</p>
<ul>
<li>CPU and parts of BIOS</li>
<li>System time</li>
<li>Video display card</li>
<li>Memory</li>
<li>Keyboard</li>
<li>Disk drives</li>
</ul>
<ul>
<li>CPU and parts of BIOS</li>
<li>System time</li>
<li>Video display card</li>
<li>Memory</li>
<li>Keyboard</li>
<li>Disk drives</li>
</ul>
<p>If the necessary hardware is detected and found to be operating properly, the computer begins to boot. If the hardware is not detected or is found not to be operating properly, the BIOS issues an error message. This error message may be text on the display screen and/or a series of coded beeps, depending on the nature of the problem. Since the POST runs before the computer's video card is activated, it may not be possible to progress to the display screen. The pattern of beeps may be a variable number of short beeps or a mixture of long and short beeps, depending on what type of BIOS is installed. The pattern of beeps contains messages about the nature of the problem detected. For example, if the keyboard is not detected, a particular pattern of beeps will inform you of that fact. An error found in the POST is usually fatal (that is, it causes the current program to stop running) and will halt the boot process, since the hardware checked is absolutely essential for the computer's functions.</p>
<p>開機時，POST（開機自檢）是電腦基本輸入/輸出系統（或“啟動程序”）運行以確定電腦鍵盤，隨機存取存儲器，磁碟驅動器的診斷測試順序。 ，並且其他硬體運行正常。 POST是BIOS在啟動時執行的初始測試。 POST的作用是查找硬體錯誤，並報告這些錯誤。 POST檢查以下內容：</p>
<ul>
<li>CPU和部分BIOS</li>
<li>系統時間</li>
<li>影像顯示卡</li>
<li>記憶體</li>
<li>鍵盤</li>
<li>磁碟驅動器</li>
</ul>
<ul>
<li>CPU和部分BIOS</li>
<li>系統時間</li>
<li>影像顯示卡</li>
<li>記憶體</li>
<li>鍵盤</li>
<li>磁碟驅動器</li>
</ul>
<p>如果檢測到必要的硬體並發現其運行正常，則電腦將開始啟動。如果未檢測到硬體或發現硬體運行不正常，BIOS將發出錯誤訊息。根據問題的性質，此錯誤訊息可能是顯示器上的文字和/或一系列編碼的嗶聲。由於POST在啟動電腦的顯示卡之前運行，因此可能無法進入顯示螢幕。嗶聲的模式可以是可變數目的短嗶聲，也可以是長短嗶聲的混合，具體取決於安裝的BIOS類型。嗶聲的模式包含有關所檢測問題性質的訊息。例如，如果未檢測到鍵盤，則特定的嗶嗶聲將告知您該情況。在POST中發現的錯誤通常是致命的（也就是說，它導致當前程序停止運行），並且將終止啟動過程，因為檢查的硬體對於電腦的功能是絕對必要的。</p>
<p></p>
<p>The pattern of beeps is like Morse code. The number and sequence of beeps has a meaning set by the computer manufacturer. Therefore, the meaning of each beep differs by manufacturer. A chart that includes some AMI and Dell beep codes is shown below.</p>
<p> </p>
<p><strong>BEEP CODE COMPARISON CHART</strong></p>
<table>
<thead>
<tr>
<td>
<p><strong>BEEP CODE</strong></p>
</td>
<td>
<p><strong>AMI</strong></p>
</td>
<td>
<p><strong>DELL</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>DRAM refresh failure</p>
</td>
<td>
<p>BIOS ROM corruption or failure</p>
</td>
</tr>
<tr>
<td>
<p>2</p>
</td>
<td>
<p>Parity circuit failure</p>
</td>
<td>
<p>RAM not detected</p>
</td>
</tr>
<tr>
<td>
<p>3</p>
</td>
<td>
<p>Base 64K RAM failure</p>
</td>
<td>
<p>Motherboard failure</p>
</td>
</tr>
<tr>
<td>
<p>4</p>
</td>
<td>
<p>System timer failure</p>
</td>
<td>
<p>RAM failure</p>
</td>
</tr>
<tr>
<td>
<p>5</p>
</td>
<td>
<p>Process failure</p>
</td>
<td>
<p>CMOS battery failure</p>
</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<td>
<p><strong>BEEP CODE</strong></p>
</td>
<td>
<p><strong>AMI</strong></p>
</td>
<td>
<p><strong>DELL</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>DRAM refresh failure</p>
</td>
<td>
<p>BIOS ROM corruption or failure</p>
</td>
</tr>
<tr>
<td>
<p>2</p>
</td>
<td>
<p>Parity circuit failure</p>
</td>
<td>
<p>RAM not detected</p>
</td>
</tr>
<tr>
<td>
<p>3</p>
</td>
<td>
<p>Base 64K RAM failure</p>
</td>
<td>
<p>Motherboard failure</p>
</td>
</tr>
<tr>
<td>
<p>4</p>
</td>
<td>
<p>System timer failure</p>
</td>
<td>
<p>RAM failure</p>
</td>
</tr>
<tr>
<td>
<p>5</p>
</td>
<td>
<p>Process failure</p>
</td>
<td>
<p>CMOS battery failure</p>
</td>
</tr>
</tbody>
</table>
<p><strong>BEEP CODE</strong></p>
<p><strong>AMI</strong></p>
<p><strong>DELL</strong></p>
<p>1</p>
<p>DRAM refresh failure</p>
<p>BIOS ROM corruption or failure</p>
<p>2</p>
<p>Parity circuit failure</p>
<p>RAM not detected</p>
<p>3</p>
<p>Base 64K RAM failure</p>
<p>Motherboard failure</p>
<p>4</p>
<p>System timer failure</p>
<p>RAM failure</p>
<p>5</p>
<p>Process failure</p>
<p>CMOS battery failure</p>
<p><strong>BEEP CODE</strong></p>
<p><strong>AMI</strong></p>
<p><strong>DELL</strong></p>
<p>1</p>
<p>DRAM refresh failure</p>
<p>BIOS ROM corruption or failure</p>
<p>2</p>
<p>Parity circuit failure</p>
<p>RAM not detected</p>
<p>3</p>
<p>Base 64K RAM failure</p>
<p>Motherboard failure</p>
<p>4</p>
<p>System timer failure</p>
<p>RAM failure</p>
<p>5</p>
<p>Process failure</p>
<p>CMOS battery failure</p>
<p><strong>BEEP CODE</strong></p>
<p><strong>AMI</strong></p>
<p><strong>DELL</strong></p>
<p>1</p>
<p>DRAM refresh failure</p>
<p>BIOS ROM corruption or failure</p>
<p>2</p>
<p>Parity circuit failure</p>
<p>RAM not detected</p>
<p>3</p>
<p>Base 64K RAM failure</p>
<p>Motherboard failure</p>
<p>4</p>
<p>System timer failure</p>
<p>RAM failure</p>
<p>5</p>
<p>Process failure</p>
<p>CMOS battery failure</p>
<p><br/>嗶聲的模式類似於摩斯密碼。 嗶聲的數量和順序具有電腦製造商設定的含義。 因此，每個嗶嗶聲的含義因製造商而異。 包含一些AMI和Dell嗶聲代碼的圖表如下所示。</p>
<p> </p>
<p><strong>蜂鳴碼比較表</strong></p>
<table>
<thead>
<tr>
<td>
<p><strong>嗶聲代碼</strong></p>
</td>
<td>
<p><strong>AMI</strong></p>
</td>
<td>
<p><strong>DELL</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>DRAM刷新失敗</p>
</td>
<td>
<p>BIOS ROM損壞或故障</p>
</td>
</tr>
<tr>
<td>
<p>2</p>
</td>
<td>
<p>奇偶校驗電路故障</p>
</td>
<td>
<p>未檢測到RAM</p>
</td>
</tr>
<tr>
<td>
<p>3</p>
</td>
<td>
<p>基本64K RAM故障</p>
</td>
<td>
<p>主機板故障</p>
</td>
</tr>
<tr>
<td>
<p>4</p>
</td>
<td>
<p>系統計時器故障</p>
</td>
<td>
<p>RAM 故障</p>
</td>
</tr>
<tr>
<td>
<p>5</p>
</td>
<td>
<p>處理失敗</p>
</td>
<td>
<p>CMOS電池故障</p>
</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<td>
<p><strong>嗶聲代碼</strong></p>
</td>
<td>
<p><strong>AMI</strong></p>
</td>
<td>
<p><strong>DELL</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>DRAM刷新失敗</p>
</td>
<td>
<p>BIOS ROM損壞或故障</p>
</td>
</tr>
<tr>
<td>
<p>2</p>
</td>
<td>
<p>奇偶校驗電路故障</p>
</td>
<td>
<p>未檢測到RAM</p>
</td>
</tr>
<tr>
<td>
<p>3</p>
</td>
<td>
<p>基本64K RAM故障</p>
</td>
<td>
<p>主機板故障</p>
</td>
</tr>
<tr>
<td>
<p>4</p>
</td>
<td>
<p>系統計時器故障</p>
</td>
<td>
<p>RAM 故障</p>
</td>
</tr>
<tr>
<td>
<p>5</p>
</td>
<td>
<p>處理失敗</p>
</td>
<td>
<p>CMOS電池故障</p>
</td>
</tr>
</tbody>
</table>
<p><strong>嗶聲代碼</strong></p>
<p><strong>AMI</strong></p>
<p><strong>DELL</strong></p>
<p>1</p>
<p>DRAM刷新失敗</p>
<p>BIOS ROM損壞或故障</p>
<p>2</p>
<p>奇偶校驗電路故障</p>
<p>未檢測到RAM</p>
<p>3</p>
<p>基本64K RAM故障</p>
<p>主機板故障</p>
<p>4</p>
<p>系統計時器故障</p>
<p>RAM 故障</p>
<p>5</p>
<p>處理失敗</p>
<p>CMOS電池故障</p>
<p><strong>嗶聲代碼</strong></p>
<p><strong>AMI</strong></p>
<p><strong>DELL</strong></p>
<p>1</p>
<p>DRAM刷新失敗</p>
<p>BIOS ROM損壞或故障</p>
<p>2</p>
<p>奇偶校驗電路故障</p>
<p>未檢測到RAM</p>
<p>3</p>
<p>基本64K RAM故障</p>
<p>主機板故障</p>
<p>4</p>
<p>系統計時器故障</p>
<p>RAM 故障</p>
<p>5</p>
<p>處理失敗</p>
<p>CMOS電池故障</p>
<p><strong>嗶聲代碼</strong></p>
<p><strong>AMI</strong></p>
<p><strong>DELL</strong></p>
<p>1</p>
<p>DRAM刷新失敗</p>
<p>BIOS ROM損壞或故障</p>
<p>2</p>
<p>奇偶校驗電路故障</p>
<p>未檢測到RAM</p>
<p>3</p>
<p>基本64K RAM故障</p>
<p>主機板故障</p>
<p>4</p>
<p>系統計時器故障</p>
<p>RAM 故障</p>
<p>5</p>
<p>處理失敗</p>
<p>CMOS電池故障</p>
<p><em><strong>EXAMPLE</strong></em></p>
<p>Here is a sample beep code from a computer having a problem:</p>
<p>This beep code consists of two short beeps. What does this POST beep sequence mean? It depends on the BIOS’s manufacturer.</p>
<p>Use a search engine to search for "AMI beep codes." <a href="http://www.bioscentral.com/beepcodes/amibeep.htm">This might be a typical result.</a> This website tells us that on an AMI computer, two short beeps indicate a memory parity error.</p>
<p>Now search for "AST Research BIOS beep codes." <a href="http://www.bioscentral.com/beepcodes/astbeep.htm">Here is a typical result.</a> This website tells us that on an AST Research BIOS computer, two short beeps indicate a keyboard controller buffer failure.</p>
<p>An Internet search for "IBM bios beep codes" would indicate that this beep code indicates a POST error, and that you should review the screen for the error code.</p>
<p>Knowing the BIOS manufacturer is important when diagnosing a problem during the POST, as the meaning of the beep codes vary by manufacturer.</p>
<p>範例</p>
<p>嗶聲代碼</p>
<p>這是有問題的電腦發出的嗶嗶代碼範例：</p>
<p>此蜂鳴聲代碼包含兩個短蜂鳴聲。 這個POST嗶嗶聲序列是什麼意思？ 這取決於BIOS的製造商。</p>
<p>使用搜尋引擎搜尋“ AMI蜂鳴聲代碼”。 這可能是典型的結果。 該網站告訴我們，在AMI計算機上，兩聲短促的嗶嗶聲表示內存奇偶校驗錯誤。</p>
<p>現在搜尋“ AST Research BIOS嗶聲代碼”。 這是一個典型的結果。 該網站告訴我們，在AST Research BIOS計算機上，兩聲短促的嗶嗶聲表示鍵盤控制器緩衝區故障。</p>
<p>如果在Internet上搜尋“ IBM bios嗶聲代碼”，則表明該嗶聲代碼指示POST錯誤，因此您應該在螢幕上查看錯誤代碼。</p>
<p>在POST中診斷問題時，了解BIOS製造商很重要，因為嗶嗶代碼的含義因製造商而異。<br/><br/></p>
<p style="line-height: 18.0pt; background: white; vertical-align: baseline; margin: 6.0pt 0cm 9.6pt 0cm;"><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Georgia',serif; color: #241d1d;">So how is the BIOS updated? Recall that BIOS is firmware, or software on a chip. BIOS needs updating when there are power management issues or a processor is upgraded. Always check the manufacturer’s website for the latest firmware version. In the old systems (1980s-1990s), the actual BIOS chip had to be replaced entirely. In newer systems, the BIOS is “flashed.” Flashing is a special process in which the BIOS is overwritten, and shouldn’t be done unless absolutely necessary. Always be sure to back up information before doing a BIOS flash; if a flash doesn’t occur successfully, the system can be irrevocably broken to the point that it will no longer boot.<o:p></o:p></span></p>
<p style="line-height: 18.0pt; background: white; vertical-align: baseline; margin: 6.0pt 0cm 9.6pt 0cm;"><span lang="EN-US" style="font-size: 13.5pt; font-family: 'Georgia',serif; color: #241d1d;"><img alt="" height="285" src="./../images/6-23.png" width="359"/></span></p>
<p style="line-height: 18.0pt; background: white; vertical-align: baseline; margin: 6.0pt 0cm 9.6pt 0cm;"><img alt="" height="390" src="./../images/6-23.png" width="491"/></p>
<p>那麼如何更新BIOS？ 回想一下，BIOS是硬體或芯片上的軟體。 出現電源管理問題或升級處理器時，BIOS需要更新。 請經常在製造商的網站上查看最新硬體版本。 在舊系統（1980年代至1990年代）中，實際的BIOS芯片必須完全更換。 在較新的系統中，BIOS被“刷新”。 刷新是一個特殊的過程，其中BIOS被覆蓋，除非絕對必要，否則不應該這樣做。 經常確保在執行BIOS刷新之前備份信息； 如果無法成功進行刷新，則系統將無法恢復，甚至無法啟動。</p>
<p></p>
<p></p>
<br />40923238鄒杰-1 << <a href='40923238鄒杰-1.html'>Previous</a> <a href='PCH 18: Laptop and Notebook Component Replacement.html'>Next</a> >> PCH 18: Laptop and Notebook Component Replacement</div>
        
    <!-- footer -->
      <div class="container">
        <div class="row pt-3 mx-auto">
            <p>
            <!-- Link back to Colorlib can't be removed. Template is licensed under CC BY 3.0. -->
            Copyright &copy;<script>document.write(new Date().getFullYear());</script> All rights reserved | This template is made with <i class="icon-heart" aria-hidden="true"></i> by <a href="https://colorlib.com" target="_blank" >Colorlib</a>
            <!-- Link back to Colorlib can't be removed. Template is licensed under CC BY 3.0. -->
            </p>
        </div>
      </div>
    <!-- for footer -->
    
        </div> <!-- for site wrap -->
            <!-- <script src="../cmsimde/static/chimper/js/jquery-3.3.1.min.js"></script> -->
            <script src="../cmsimde/static/chimper/js/jquery-migrate-3.0.1.min.js"></script>
            <script src="../cmsimde/static/chimper/js/jquery-ui.js"></script>
            <script src="../cmsimde/static/chimper/js/popper.min.js"></script>
            <script src="../cmsimde/static/chimper/js/bootstrap.min.js"></script>
            <script src="../cmsimde/static/chimper/js/owl.carousel.min.js"></script>
            <script src="../cmsimde/static/chimper/js/jquery.stellar.min.js"></script>
            <script src="../cmsimde/static/chimper/js/jquery.countdown.min.js"></script>
            <script src="../cmsimde/static/chimper/js/jquery.magnific-popup.min.js"></script>
            <script src="../cmsimde/static/chimper/js/bootstrap-datepicker.min.js"></script>
            <script src="../cmsimde/static/chimper/js/aos.js"></script>
            <!--
            <script src="../cmsimde/static/chimper/js/typed.js"></script>
                    <script>
                    var typed = new Typed('.typed-words', {
                    strings: ["Web Apps"," WordPress"," Mobile Apps"],
                    typeSpeed: 80,
                    backSpeed: 80,
                    backDelay: 4000,
                    startDelay: 1000,
                    loop: true,
                    showCursor: true
                    });
                    </script>
            -->
            <script src="../cmsimde/static/chimper/js/main.js"></script>
        
<!-- 啟用 LaTeX equations 編輯 -->
  <!-- <script>
  MathJax = {
    tex: {inlineMath: [['$', '$'], ['\(', '\)']]}
  };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>-->
    </body></html>
        